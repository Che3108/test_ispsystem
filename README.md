# Тестовое задание на должность backend-разработчика в [ISPsystem](https://www.ispsystem.ru)

Стек - python3<br> 
[Текст задания](https://drive.google.com/file/d/1WNlQlvxHQb0n-F2OuvqjSgsHDNatrJxF/view?usp=sharing)


## Итоговый обзор работы
Для выполнения задания рассматривались три различных варианта:
1) Использование команд <b>wget</b>, <b>tar</b>, <b>ls</b>, <b>rm</b> оболочки <b>bash</b>.<br> 
Так как микросервис предполагается портировать в docker-контейнер, то одним из рассматриваемых вариантов было использование bash-скриптов для выполнения      основого функцианала микросервиса (загрузка архива, распаковка, удаление).
2) Использование фреймворка [FastAPI](https://fastapi.tiangolo.com) для создания микросервиса.<br>
FastAPI - является самым простым и быстрым способом реализации RestAPI-приложений. 
3) Построение обработчика запросов на основе класса <b>BaseHTTPRequestHandler</b> из модуля <b>http.server</b> и реализация сервера на основе класса <b>TCPServer</b> модуля <b>socketserver</b>.</p>
<p>В итоге для реализации был выбран последний вариант. Так как из рассмотренных, первый слабо подходит для продакшена, второй вариант самый лучший для продакшена, но излишне функцианален для поставленной задачи. Третий же вариант представляется мне самым удобным.</p>
<p>В целом по заданию выполнены все пункты основной части, а так же 1-й, 4-й, 6-й из дополнительной части. Микросирвис является асинхронным (реализовано с помощью модуля <b>threading</b>) и состоит из 4-х исполняемых файлов: <b>download.py</b>, <b>my_server.py</b>, <b>main.py</b>, <b>json_pars.py</b>. Рассмотрим исполняемые файлы детальнее.</p><br>

## Описание модулей
### download.py
download.py содержит основной класс микросервиса - DownloadMaster, который непосредственно и занимается загрузкой, распаковкой, удалением архивов, а так же показывает состояние на каждом этапе обработки архива. <br>
<p><b>Метод download(url)</b> занимается непосредственно загрузкой архива по URL-адресу и его распаковкой. На вход метод получает URL-адрес архива, в результате работы записывает  в переменную status состояние downloading с указанием прогресса загрузки. Загрузка производиться порциями объемом 1MB, регулировать размер порции позволяет параметр chunk_size, указываемый при инициализации класса. Распаковка производится вызовом метода extract(). В случае получения исключения при загруке,  в переменную status записывается сообщение об исключении. Для работы метода использованы модуль requests, а для обработки исключений использован класс HTTPError из модуля requests.exceptions совместно с конструкцией try .. except.</p>
<p><b>Метод extract()</b> выполняет распаковку загруженного архива с помощью модуля tarfile. В результате работы метода архив распаковывается в папку с такимже именем как и имя архива, а в переменную files записывается список распакованных файлов. Так же в переменную status записывается состояние unpacking.</p>
<p><b>Метод delete_arh()</b> выполняет удаление архива и распакованной информации. Удаление производится с помощью модулей os и shutil.</p>
<p><b>Метод get_status()</b> собирает информацию о состоянии обработки на каждом этапе и, вместе с id архива, возращает его в видете готового json-объекта.</p><br>

### my_server.py
my_server.py содержит класс MyHTTPHandler - обработчик запросов. В классе MyHTTPHandler реализовано три обработчиа: do_POST(), do_GET(), do_DELETE().
<p><b>Обработчик do_POST()</b> заниематся обработкой POST-запроса по пути /arhive. При получении POST-запроса производится проверка правильности пути, затем корректности полученной информации. Проверку корретности полученной информации выполняет функция json_pars(testing_json) из модуля json_pars. После проверки правильности полученной информации, архиву присваивается уникальный номер (целая часть от текущего времени в формате UNIX) и создается экземпляр класса DownloadMaster для дальнейшей работы с архивом. Уникальный номер архива записывается в качестве ключа в словарь arh_id_base (импровизированная база данных архивов в работе), а экземпляр класса DownloadMaster записывается в качетве значения этого ключа. Далее, в отдельном потоке выполняется загрузка и распаковка архива методом download(url) класса DownloadMaster. По результатам проверок формируется ответ на запрос. Ответом может быть код 200(OK) и json-объект с id архива, либо код 400(Bad Request) c указанием деталей.</p>
<p><b>Обработчик do_GET()</b> заниематся обработкой GET-запроса по пути /arhive. При получении GET-запроса производится проверка правильности пути, затем корректности полученной информации. Проверка корретности полученной информации выполняется путем проверки наличия указанной информации среди ключей словаря arh_id_base. После проверки правильности полученной информации, формируется ответ на запрос по указанному номеру архива. Ответом может быть код 200(OK) и json-объект с id архива и его состоянием, либо код 400(Bad Request) c указанием деталей.</p>
<p><b>Обработчик do_DELETE()</b> заниематся обработкой DELETE-запроса по пути /arhive. При получении DELETE-запроса производится проверка правильности пути, затем корректности полученной информации. Проверка корретности полученной информации выполняется путем проверки наличия указанной информации среди ключей словаря arh_id_base. После проверки правильности полученной информации, в отдельном потоке выполняется удаление архива и формируется ответ на запрос по указанному номеру архива. Ответом может быть код 200(OK) и json-объект с id архива и его состоянием, либо код 400(Bad Request) c указанием деталей.</p><br>

### json_pars.py
json_pars.py содержит функцию json_pars(testing_json). Основной задачей функции является проверка входящего json-объекта на соответствие ожиданием сервера, тем самым реализуется защита приложения от нежелательных запросов. Функция json_pars(testing_json) вынесена в отдельный модуль исключительно с эстетической точки зрения.<br><br><br>

## Как начать?
Скачиваем исполняемые файлы <b>download.py</b>, <b>my_server.py</b>, <b>main.py</b>, <b>json_pars.py</b>. Запускаем скрипт <b>main.py</b>, при необходимости изменив значение переменной PORT.

## Тестирование
Результаты тестирования основных функция находятся в файле <b>test_server.txt</b>.<br>
Результаты тестирования с помощью утилиты <b>pylint</b> файла <b>main.py</b> находятся в файле <b>linter_main_py.txt</b>.<br>
Результаты тестирования с помощью утилиты <b>pylint</b> файла <b>download.py</b> находятся в файле <b>linter_download_py.txt</b>.<br>
Результаты тестирования с помощью утилиты <b>pylint</b> файла <b>my_server.py</b> находятся в файле <b>linter_my_server_py.txt</b>.<br>
Результаты тестирования с помощью утилиты <b>pylint</b> файла <b>json_pars.py</b> находятся в файле <b>linter_json_pars_py.txt</b>.<br><br>
прим. Утилита pylint показывает отсутствие строки документации к функциям, что странно, так как функции документированы.
